Skvělé. Níže máš **finální podrobný strategický plán refaktoringu projektu „Final Cue Sheet Checker“**.
Je plně v souladu s principy *KISS*, s metodikou z dokumentu *Strategie refaktoringu monolitické Python aplikace* a s tvojí realitou (jeden vývojář, bez CI, důraz na bezpečnost a testovatelnost).
Obsahuje i popis souborové struktury a architektonické diagramy.

---

# 🧭 **Strategický plán refaktoringu – Final Cue Sheet Checker**

---

## 1. Filozofie a cíle refaktoringu

### 1.1 Cíl

Transformovat aplikaci „Final Cue Sheet Checker“ do **dlouhodobě udržitelného, testovatelně stabilního a architektonicky čistého modulárního monolitu**, aniž by se změnilo její aktuální chování.

### 1.2 Zásady

* **KISS** – každý krok má přinést konkrétní hodnotu s minimálním kódem. Žádné „pro jistotu“ abstrakce.
* **Iterativní přístup** – po každé fázi je aplikace funkční a testy procházejí.
* **Behaviorální parita** – refaktoring nesmí měnit výsledky aplikace.
* **Testy jako pojistka** – každý krok chráněn charakterizačními a unit testy.
* **Modular monolith** – jasně vymezené vrstvy (UI / services / core / adapters) bez distribuční složitosti mikroservis.

---

## 2. Architektura a cílová struktura projektu

### 2.1 Přehled vrstev

| Vrstva            | Účel                                                                | Příklady modulů                                                                                          |
| :---------------- | :------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------- |
| **UI**            | Řídí interakci s uživatelem (Qt GUI, CLI). Žádná logika.            | `ui/main_window.py`, `app.py`                                                                            |
| **Services**      | Orchestrace aplikace – spojuje doménu a adaptéry.                   | `services/analysis_service.py`, `services/export_service.py`                                             |
| **Core (Domain)** | Čistá logika a datové modely, žádný I/O.                            | `core/domain/comparison.py`, `core/domain/extraction.py`, `core/models/analysis.py`                      |
| **Adapters**      | Komunikace s okolním světem (souborový systém, audio knihovny, AI). | `adapters/filesystem/file_discovery.py`, `adapters/audio/wav_reader.py`, `adapters/pdf/pdf_extractor.py` |

---

### 2.2 Cílová souborová struktura

```
final_cue_sheet_checker/
│
├── ui/
│   ├── main_window.py
│   ├── app.py
│   └── config_models.py
│
├── services/
│   ├── analysis_service.py
│   ├── export_service.py
│   └── __init__.py
│
├── core/
│   ├── domain/
│   │   ├── comparison.py
│   │   ├── extraction.py
│   │   └── __init__.py
│   ├── models/
│   │   ├── analysis.py
│   │   └── __init__.py
│   ├── ports.py
│   └── __init__.py
│
├── adapters/
│   ├── filesystem/
│   │   ├── file_discovery.py
│   │   └── __init__.py
│   ├── audio/
│   │   ├── wav_reader.py
│   │   ├── ai_mode_detector.py
│   │   └── __init__.py
│   ├── pdf/
│   │   ├── pdf_extractor.py
│   │   └── __init__.py
│   └── __init__.py
│
├── tests/
│   ├── test_core/
│   ├── test_services/
│   ├── test_adapters/
│   └── data/ (golden JSON, ZIP, PDF)
│
├── tools/
│   ├── check.sh
│   └── __init__.py
│
└── pyproject.toml
```

---

### 2.3 Architektonické diagramy

#### **Komponentový diagram (vrstvy a závislosti)**

```
+------------------------------+
|           UI Layer           |
| (Qt GUI, CLI, entry point)   |
+-------------+----------------+
              |
              v
+-------------+----------------+
|           Services            |
| - AnalysisService             |
| - ExportService               |
+-------------+----------------+
              |
              v
+-------------+----------------+
|             Core             |
|  (pure domain logic + models)|
+-------------+----------------+
              |
              v
+-------------+----------------+
|           Adapters           |
| Filesystem / Audio / PDF / AI|
+------------------------------+
```

#### **Datový tok (workflow aplikace)**

```
[UI Action]
   |
   v
[AnalysisService]
   |
   +--> discover_and_pair_files() [Filesystem Adapter]
   |
   +--> extract_wav_files() [Audio Adapter]
   |
   +--> compare_data() [Core Domain]
   |
   +--> export_results_to_json() [Export Service → Filesystem]
   |
   v
[UI displays results]
```

---

## 3. Fázovaný plán refaktoringu (bez CI, s lokální kontrolou kvality)

Každá fáze je **nasaditelná**, testy musí být po dokončení zelené, `tools/check.sh` bez chyb.

---

### **Fáze 1 – Stabilizace a baseline**

**Cíl:**
Upevnit současné chování, odstranit zjevné typové a logické nekonzistence.

**Kroky:**

1. Opravit typy v `SideResult` a `compare_data` (nepoužívat `model_dump()` u polí s modely).
2. Opravit mrtvý `logging.info()` v `discover_and_pair_files`.
3. Zajistit funkční charakterizační testy (golden JSONy, výstupy).
4. Přidat skript `tools/check.sh` pro lokální lint/type/test běh.

**Výsledek:**
Kód čistý, typově konzistentní, testy potvrzují stejné chování.

---

### **Fáze 2 – Odstranění globálních závislostí a DI**

**Cíl:**
Zrušit závislost na globálním `cfg`, zavést explicitní dependency injection.

**Kroky:**

1. Vytvořit `IdExtractionSettings`, `ToleranceSettings`, `ExportSettings` (dataclass / Pydantic).
2. Entry point (`app.py` nebo `main_window.py`) sestaví tyto objekty a předá je do `AnalysisService`.
3. Upravit signatury:

   * `extract_numeric_id(filename, settings: IdExtractionSettings)`
   * `discover_and_pair_files(..., id_settings: IdExtractionSettings)`
   * `compare_data(..., tolerance_settings: ToleranceSettings)`
4. Upravit testy – parametrize různé kombinace nastavení.

**Výsledek:**
Žádné globální proměnné, deterministické testy, čisté rozhraní funkcí.

---

### **Fáze 3 – Modularizace I/O**

**Cíl:**
Vyčistit doménu od I/O kódu a přesunout jej do adaptérů.

**Kroky:**

1. Vytvořit `adapters/audio/wav_reader.py`:

   ```python
   class ZipWavFileReader:
       def extract_wav_files(self, zip_path: Path) -> list[WavFile]:
           ...
   ```
2. Přesunout čtení ZIPů, trvání WAVů a fallbacky sem.
3. Upravit `core/domain/extraction.py`, aby používal `WavFile` objekty, ne přímo soubory.
4. Jednotkové testy adapteru (valid ZIP, poškozený, prázdný, fallback).

**Výsledek:**
Doména je čistě logická, I/O testováno izolovaně.

---

### **Fáze 4 – Export jako služba**

**Cíl:**
Jednotné místo pro export, snadná konfigurace, žádná logika v UI.

**Kroky:**

1. Vytvořit `services/export_service.py` s funkcí:

   ```python
   def export_results_to_json(results: list[SideResult], settings: ExportSettings) -> Optional[Path]:
       ...
   ```
2. UI i AnalysisService volají jen tuto službu.
3. Testy na: auto export, vytvoření adresáře, write failure.

**Výsledek:**
Centralizovaný, testovatelný export, žádné duplicity.

---

### **Fáze 5 – Port pro AI detekci (volitelné)**

**Cíl:**
Oddělit AI detekci režimu zvuku do portu – testovatelná rozšiřitelnost.

**Kroky:**

1. V `core/ports.py` přidat:

   ```python
   class AudioModeDetector(Protocol):
       def detect(self, wavs: list[WavInfo]) -> dict[str, list[WavInfo]]:
           ...
   ```
2. Implementovat `AiAudioModeDetector` v `adapters/audio/ai_mode_detector.py`.
3. Implementovat `FakeAudioModeDetector` pro testy.
4. `AnalysisService` dostane detektor přes konstruktor.

**Výsledek:**
AI logika izolovaná, testy mohou používat fake implementaci.

**✅ FAZE 5 DOKONČENA** (22.10.2025):
- AudioModeDetector Protocol vytvořen v core/ports.py
- AiAudioModeDetector implementuje AI-backed detekci v adapters/audio/ai_mode_detector.py
- FakeAudioModeDetector poskytuje deterministické testy v adapters/audio/fake_mode_detector.py
- AnalysisService přijímá detector přes konstruktor s default na AiAudioModeDetector()
- Hexagonální architektura dokončena - všechny infrastrukturní závislosti izolovány za porty
- 10 unit testů pro detektory (5 AI adapter, 5 fake adapter)
- 2 integrační testy používající fake detector fixture
- Kvalitní brány prošly: pytest (55 testů), coverage 97%, ruff bez chyb
- AI izolace ověřena: pouze adapters/audio/ai_mode_detector.py importuje z wav_extractor_wave
- Doména čistá: core/domain/comparison.py má nulové AI infrastrukturní závislosti

---

## 4. Prevence chyb a regresí

| Riziko                           | Prevence                                   |
| :------------------------------- | :----------------------------------------- |
| Změna chování během refaktoringu | Charakterizační testy (golden outputs).    |
| Typové chyby                     | `mypy --strict` v `tools/check.sh`.        |
| Zapomenuté importy/unused code   | `ruff check .`.                            |
| Náhodné změny v UI               | UI testuje se pouze skrze service výstupy. |
| Přenos chyb z I/O do domény      | Oddělení vrstev, testy adapterů zvlášť.    |

---

## 5. Lokální kontrola kvality (bez CI)

**`tools/check.sh`**

```bash
#!/usr/bin/env bash
set -euo pipefail
python -m pytest -q
coverage run -m pytest
coverage report --fail-under=85
ruff check .
mypy --strict .
openspec validate --strict
echo "All checks passed ✅"
```

> Výsledek: všechny brány testovány lokálně, CI není potřeba.

---

## 6. Měřitelné indikátory úspěchu

| Fáze | Ukazatel         | Měřítko úspěchu                                         |
| :--- | :--------------- | :------------------------------------------------------ |
| F1   | Typová stabilita | `mypy` bez chyb, všechny testy zelené                   |
| F2   | DI bez globálů   | žádný `import cfg` mimo `app.py`                        |
| F3   | Oddělené I/O     | `core/domain` neobsahuje žádný `open()`, `os`           |
| F4   | Export           | Jediná funkce `export_results_to_json`, 100 % test pass |
| F5   | AI port          | `AudioModeDetector` testovaný s fake adapt.             |

---

## 7. Shrnutí strategie

1. Postupuj **po fázích**, nikdy ne více oblastí v jednom PR.
2. Po každé fázi spusť `tools/check.sh`.
3. Nepřidávej žádné nové funkce – refaktoring = stejná funkčnost, čistší kód.
4. Každou novou třídu/test si zaznamenej v dokumentaci projektu.
5. Po dokončení F4 máš stabilní, plně testovatelný základ. F5 je volitelná nadstavba.

---

## 8. Závěr

Tento plán:

* minimalizuje riziko (každý krok je reverzibilní),
* je v souladu s principy z *Clean Code in Python* a *Working Effectively with Legacy Code*,
* zachovává KISS,
* je proveditelný jedním vývojářem bez CI infrastruktury,
* poskytuje měřitelné výsledky po každé iteraci.

---

Chceš, abych nyní k tomuto plánu doplnil i konkrétní **návrhy diagramů ve formátu PlantUML** (komponentový a datový tok), které můžeš přímo vykreslit do dokumentace projektu?

---

## 9. Refactoring Completion Summary

**Completion Date:** 22 October 2025

**All 5 Phases Successfully Completed** ✅

### Archive Dates:
- **Phase 1 (Stabilization):** 2025-10-21
- **Phase 2 (Dependency Injection):** 2025-10-21
- **Phase 3 (I/O Modularization):** 2025-10-21
- **Phase 4 (Export Service):** 2025-10-22
- **Phase 5 (AI Port):** 2025-10-22

### Success Metrics Achieved:

**F1 (Type Stability):** ✅ mypy --strict passes
- All type annotations valid
- No type: ignore comments needed in core domain logic
- Strict type checking enforced across entire codebase

**F2 (DI Without Globals):** ✅ No cfg in core/domain or adapters
- Global configuration eliminated from domain and adapter layers
- Settings dataclasses with explicit dependency injection
- Entry points responsible for configuration loading and injection

**F3 (Separated I/O):** ✅ No I/O imports in core/domain
- Domain layer completely free of infrastructure dependencies
- File operations, ZIP/WAV reading isolated in adapter layer
- Clean separation between business logic and I/O concerns

**F4 (Export):** ✅ Single function in services/export_service.py
- Centralized `export_results_to_json()` function
- UI and automated tests use same export mechanism
- No duplicate export logic across codebase

**F5 (AI Port):** ✅ Only adapters/audio/ai_mode_detector.py imports AI
- AudioModeDetector protocol enables clean abstraction
- AI dependencies isolated behind port interface
- Fake adapter enables deterministic testing without external APIs

### Final Quality Metrics:
- **Test Coverage:** 97% (55 passing tests)
- **Test Count:** 55 comprehensive tests including characterization tests
- **Code Quality:** ruff clean, zero dead code, no unreachable statements
- **Type Safety:** mypy --strict passes across entire codebase
- **Architecture:** Complete hexagonal architecture implemented

### Verification Commands Used:
```bash
# Success metrics verification
rg "from config import cfg" core/domain/ adapters/  # Expected: No matches
rg "(import os|import zipfile)" core/domain/        # Expected: No matches
rg "def export_results_to_json"                      # Expected: Only services/export_service.py
rg "from wav_extractor_wave import"                 # Expected: Only adapters/audio/ai_mode_detector.py

# Quality gates
tools/check.sh                                      # All checks pass ✅
```

### Architectural Achievements:
- **Hexagonal Architecture:** Complete implementation with clear layer boundaries
- **Dependency Inversion:** Domain depends on abstractions (ports), not concretions
- **Clean Architecture:** Infrastructure concerns properly isolated
- **Testability:** Every layer independently testable with appropriate fakes/mocks
- **Maintainability:** Clear separation of concerns, explicit dependencies

### Lessons Learned:
1. **OpenSpec Integration:** Validating changes before archival ensures specification consistency
2. **Git Versioning:** Atomic commits at logical checkpoints enable safe rollback capability
3. **Fake Adapters:** Essential for fast, deterministic testing of domain logic
4. **Gradual Migration:** Each phase built upon previous, maintaining working state throughout

### Future Maintenance Guidelines:
1. **New Features:** Follow hexagonal architecture - add ports for new infrastructure dependencies
2. **Testing:** Use fake adapters for domain testing, integration tests for adapters
3. **Quality Gates:** Always run `tools/check.sh` before committing
4. **OpenSpec:** Document significant changes with OpenSpec proposals
5. **Git Workflow:** Use conventional commits with clear, descriptive messages

### Project State After Refactoring:
- **Maintainable:** Clear architecture with explicit dependencies
- **Testable:** Comprehensive test coverage with fast execution
- **Documented:** README, Strategic Plan, and CHANGELOG updated
- **Versioned:** Git tag `v1.0.0-refactoring-complete` marks completion milestone
- **Validated:** All OpenSpec specifications current and valid

**🎉 REFACTORING COMPLETE - All strategic goals achieved!**
